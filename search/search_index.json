{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"FlashHTTP FlashHTTP is a fast and efficient library for working with HTTP requests and responses. It is designed with performance in mind, while still providing a simple, easy-to-use and well-supported API. Getting Started Installation Guide API Reference Examples","title":"Home"},{"location":"#flashhttp","text":"FlashHTTP is a fast and efficient library for working with HTTP requests and responses. It is designed with performance in mind, while still providing a simple, easy-to-use and well-supported API.","title":"FlashHTTP"},{"location":"#getting-started","text":"Installation Guide API Reference Examples","title":"Getting Started"},{"location":"examples/","text":"Examples Serialization #include <flashhttp/serialization.h> #define STR_LEN(s) (sizeof(s) - 1) #define ARR_SIZE(a) (sizeof(a) / sizeof(a[0])) /*...*/ const http_header_t headers[] = { { .key = \"Host\", .value = \"example.com\", STR_LEN(\"Host\"), STR_LEN(\"example.com\") }, { .key = \"User-Agent\", .value = \"Mozilla/5.0\", STR_LEN(\"User-Agent\"), STR_LEN(\"Mozilla/5.0\") }, { .key = \"Accept\", .value = \"text/html\", STR_LEN(\"Accept\"), STR_LEN(\"text/html\") }, { .key = \"Accept-Language\", .value = \"en-US\", STR_LEN(\"Accept-Language\"), STR_LEN(\"en-US\") }, { .key = \"Accept-Encoding\", .value = \"gzip, deflate, br\", STR_LEN(\"Accept-Encoding\"), STR_LEN(\"gzip, deflate, br\") }, { .key = \"DNT\", .value = \"1\", STR_LEN(\"DNT\"), STR_LEN(\"1\") }, { .key = \"Connection\", .value = \"keep-alive\", STR_LEN(\"Connection\"), STR_LEN(\"keep-alive\") }, { .key = \"Referer\", .value = \"https://example.com/previous-page\", STR_LEN(\"Referer\"), STR_LEN(\"https://example.com/previous-page\") }, { .key = \"Upgrade-Insecure-Requests\", .value = \"1\", STR_LEN(\"Upgrade-Insecure-Requests\"), STR_LEN(\"1\") }, { .key = \"Sec-Fetch-Dest\", .value = \"document\", STR_LEN(\"Sec-Fetch-Dest\"), STR_LEN(\"document\") }, { .key = \"Sec-Fetch-Mode\", .value = \"navigate\", STR_LEN(\"Sec-Fetch-Mode\"), STR_LEN(\"navigate\") }, { .key = \"Sec-Fetch-Site\", .value = \"same-origin\", STR_LEN(\"Sec-Fetch-Site\"), STR_LEN(\"same-origin\") }, { .key = \"Sec-Fetch-User\", .value = \"?1\", STR_LEN(\"Sec-Fetch-User\"), STR_LEN(\"?1\") } }; const char body[] = \"This is the body of the request\"; const http_request_t request = { .method = HTTP_GET, .path = \"/example/path/resource\", .path_len = STR_LEN(\"/example/path/resource\"), .version = HTTP_1_1, .headers = headers, .headers_count = ARR_SIZE(headers), .body = body, .body_len = STR_LEN(body) }; { char serialized_request[4096]; const uint16_t request_len = http1_serialize(buffer, &request); write(sockfd, raw_serialized_data, data_len); } { http1_serialize_write(sockfd, &request); } /*...*/ Deserialization #include <flashhttp/deserialization.h> /*...*/ char response_buffer[4096] = {0}; const uint32_t len = read(sockfd, buffer, sizeof(buffer)); http_header_t headers[HEADER_MAP_CAPACITY(7)] = {0}; http_response_t response = { .headers = headers, .headers_count = ARR_SIZE(headers) }; const uint32_t len = http1_deserialize(buffer, sizeof(buffer), &response); /*...*/","title":"Examples"},{"location":"examples/#examples","text":"","title":"Examples"},{"location":"examples/#serialization","text":"#include <flashhttp/serialization.h> #define STR_LEN(s) (sizeof(s) - 1) #define ARR_SIZE(a) (sizeof(a) / sizeof(a[0])) /*...*/ const http_header_t headers[] = { { .key = \"Host\", .value = \"example.com\", STR_LEN(\"Host\"), STR_LEN(\"example.com\") }, { .key = \"User-Agent\", .value = \"Mozilla/5.0\", STR_LEN(\"User-Agent\"), STR_LEN(\"Mozilla/5.0\") }, { .key = \"Accept\", .value = \"text/html\", STR_LEN(\"Accept\"), STR_LEN(\"text/html\") }, { .key = \"Accept-Language\", .value = \"en-US\", STR_LEN(\"Accept-Language\"), STR_LEN(\"en-US\") }, { .key = \"Accept-Encoding\", .value = \"gzip, deflate, br\", STR_LEN(\"Accept-Encoding\"), STR_LEN(\"gzip, deflate, br\") }, { .key = \"DNT\", .value = \"1\", STR_LEN(\"DNT\"), STR_LEN(\"1\") }, { .key = \"Connection\", .value = \"keep-alive\", STR_LEN(\"Connection\"), STR_LEN(\"keep-alive\") }, { .key = \"Referer\", .value = \"https://example.com/previous-page\", STR_LEN(\"Referer\"), STR_LEN(\"https://example.com/previous-page\") }, { .key = \"Upgrade-Insecure-Requests\", .value = \"1\", STR_LEN(\"Upgrade-Insecure-Requests\"), STR_LEN(\"1\") }, { .key = \"Sec-Fetch-Dest\", .value = \"document\", STR_LEN(\"Sec-Fetch-Dest\"), STR_LEN(\"document\") }, { .key = \"Sec-Fetch-Mode\", .value = \"navigate\", STR_LEN(\"Sec-Fetch-Mode\"), STR_LEN(\"navigate\") }, { .key = \"Sec-Fetch-Site\", .value = \"same-origin\", STR_LEN(\"Sec-Fetch-Site\"), STR_LEN(\"same-origin\") }, { .key = \"Sec-Fetch-User\", .value = \"?1\", STR_LEN(\"Sec-Fetch-User\"), STR_LEN(\"?1\") } }; const char body[] = \"This is the body of the request\"; const http_request_t request = { .method = HTTP_GET, .path = \"/example/path/resource\", .path_len = STR_LEN(\"/example/path/resource\"), .version = HTTP_1_1, .headers = headers, .headers_count = ARR_SIZE(headers), .body = body, .body_len = STR_LEN(body) }; { char serialized_request[4096]; const uint16_t request_len = http1_serialize(buffer, &request); write(sockfd, raw_serialized_data, data_len); } { http1_serialize_write(sockfd, &request); } /*...*/","title":"Serialization"},{"location":"examples/#deserialization","text":"#include <flashhttp/deserialization.h> /*...*/ char response_buffer[4096] = {0}; const uint32_t len = read(sockfd, buffer, sizeof(buffer)); http_header_t headers[HEADER_MAP_CAPACITY(7)] = {0}; http_response_t response = { .headers = headers, .headers_count = ARR_SIZE(headers) }; const uint32_t len = http1_deserialize(buffer, sizeof(buffer), &response); /*...*/","title":"Deserialization"},{"location":"api-reference/data-structures/","text":"Data Structures Messages Included in the flashhttp/structs.h header file. typedef enum: uint8_t { HTP_GET, HTTP_HEAD, HTTP_POST, HTTP_PUT, HTTP_DELETE, HTTP_OPTIONS, HTTP_TRACE, HTTP_PATCH, HTTP_CONNECT } http_method_t; typedef enum: uint8_t { HTTP_1_0, HTTP_1_1, HTTP_2_0, HTTP_3_0 } http_version_t; typedef struct { char *key; char *value; uint16_t key_len; uint16_t value_len; } http_header_t; typedef struct { http_method_t method; char *path; uint16_t path_len; http_version_t version; http_header_t *headers; uint16_t headers_count; char *body; uint32_t body_len; } http_request_t; typedef struct { uint16_t status_code; char *reason_phrase; uint16_t reason_phrase_len; http_header_t *headers; uint16_t headers_count; char *body; } http_response_t;","title":"Data Structures"},{"location":"api-reference/data-structures/#data-structures","text":"","title":"Data Structures"},{"location":"api-reference/data-structures/#messages","text":"Included in the flashhttp/structs.h header file. typedef enum: uint8_t { HTP_GET, HTTP_HEAD, HTTP_POST, HTTP_PUT, HTTP_DELETE, HTTP_OPTIONS, HTTP_TRACE, HTTP_PATCH, HTTP_CONNECT } http_method_t; typedef enum: uint8_t { HTTP_1_0, HTTP_1_1, HTTP_2_0, HTTP_3_0 } http_version_t; typedef struct { char *key; char *value; uint16_t key_len; uint16_t value_len; } http_header_t; typedef struct { http_method_t method; char *path; uint16_t path_len; http_version_t version; http_header_t *headers; uint16_t headers_count; char *body; uint32_t body_len; } http_request_t; typedef struct { uint16_t status_code; char *reason_phrase; uint16_t reason_phrase_len; http_header_t *headers; uint16_t headers_count; char *body; } http_response_t;","title":"Messages"},{"location":"api-reference/deserialization/","text":"Deserialization The following function prototypes can be found in the deserialization.h header file. #include <flashhttp/deserialization.h> These functions only verify the structural integrity of messages in terms of format. The body is served raw, without any decoding or parsing. It is up to the user to interpret the headers and eventually decode the body. Duplicate headers are not concatenated, but stored as separate fields. http1_deserialize uint32_t http1_deserialize(char *restrict buffer, const uint32_t buffer_size, http_response_t *const restrict response); Description deserializes a http1 response in-place by replacing delimiters with '\\0' and storing the pointers to the fields in the response struct. For the body, response->body will be set to the start of the body in the buffer or NULL if the buffer ends after the headers. Parameters buffer - the buffer which contains the full serialized response buffer_size - the size of the buffer in bytes response - the response struct where to store the deserialized fields, with the following conditions: headers already allocated with a number of fields that matches the expected number of headers headers_count set to the number of allocated headers everything else should be zeroed ( 0 ' or NULL ) Returns length of the deserialized message in bytes, minus the body 0 in case of error (see Errors ) Undefined Behavior buffer is NULL response is NULL response->headers is not allocated buffer_size is different from the actual size of the buffer buffer does not contain a full http response Errors wrong or missing status code missing reason phrase too many headers missing colon in header missing header key missing header value more than UINT16_MAX headers in the response reason phrase longer than UINT16_MAX header key longer than UINT16_MAX header value longer than UINT16_MAX","title":"Deserialization"},{"location":"api-reference/deserialization/#deserialization","text":"The following function prototypes can be found in the deserialization.h header file. #include <flashhttp/deserialization.h> These functions only verify the structural integrity of messages in terms of format. The body is served raw, without any decoding or parsing. It is up to the user to interpret the headers and eventually decode the body. Duplicate headers are not concatenated, but stored as separate fields.","title":"Deserialization"},{"location":"api-reference/deserialization/#http1_deserialize","text":"uint32_t http1_deserialize(char *restrict buffer, const uint32_t buffer_size, http_response_t *const restrict response);","title":"http1_deserialize"},{"location":"api-reference/deserialization/#description","text":"deserializes a http1 response in-place by replacing delimiters with '\\0' and storing the pointers to the fields in the response struct. For the body, response->body will be set to the start of the body in the buffer or NULL if the buffer ends after the headers.","title":"Description"},{"location":"api-reference/deserialization/#parameters","text":"buffer - the buffer which contains the full serialized response buffer_size - the size of the buffer in bytes response - the response struct where to store the deserialized fields, with the following conditions: headers already allocated with a number of fields that matches the expected number of headers headers_count set to the number of allocated headers everything else should be zeroed ( 0 ' or NULL )","title":"Parameters"},{"location":"api-reference/deserialization/#returns","text":"length of the deserialized message in bytes, minus the body 0 in case of error (see Errors )","title":"Returns"},{"location":"api-reference/deserialization/#undefined-behavior","text":"buffer is NULL response is NULL response->headers is not allocated buffer_size is different from the actual size of the buffer buffer does not contain a full http response","title":"Undefined Behavior"},{"location":"api-reference/deserialization/#errors","text":"wrong or missing status code missing reason phrase too many headers missing colon in header missing header key missing header value more than UINT16_MAX headers in the response reason phrase longer than UINT16_MAX header key longer than UINT16_MAX header value longer than UINT16_MAX","title":"Errors"},{"location":"api-reference/overview/","text":"Overview Premise Undefined behaviour is what allows the library to be fast and efficient. Programmer errors are not handled by the functions , so this library requires careful use. Note: This is a serialization library, not a parser. This means that while the functions check for the correct format, It won't handle encoding types, special headers, or any other non-standard behavior . Features that are not addressed indicate that they were intended to be managed either at the network level or at the client level. For more details, refer to the specific sections. Usage The library is divided into two main parts: serialization and deserialization. Both parts share the same data structures . You can include both the serialization and deserialization headers in your project by including the main header file: #include <flashhttp.h> otherwise, you can selectively include the headers you need: Serialization Deserialization","title":"Overview"},{"location":"api-reference/overview/#overview","text":"","title":"Overview"},{"location":"api-reference/overview/#premise","text":"Undefined behaviour is what allows the library to be fast and efficient. Programmer errors are not handled by the functions , so this library requires careful use. Note: This is a serialization library, not a parser. This means that while the functions check for the correct format, It won't handle encoding types, special headers, or any other non-standard behavior . Features that are not addressed indicate that they were intended to be managed either at the network level or at the client level. For more details, refer to the specific sections.","title":"Premise"},{"location":"api-reference/overview/#usage","text":"The library is divided into two main parts: serialization and deserialization. Both parts share the same data structures . You can include both the serialization and deserialization headers in your project by including the main header file: #include <flashhttp.h> otherwise, you can selectively include the headers you need: Serialization Deserialization","title":"Usage"},{"location":"api-reference/serialization/","text":"Serialization The following function prototypes can be found in the serialization.h header file. #include <flashhttp/serialization.h> These functions don't check the validity of messages , they assume that the message struct is already correctly filled with the right values. http1_serialize uint32_t http1_serialize(char *restrict buffer, const http_request_t *restrict request) Description serializes an HTTP/1.1 request into a buffer, adding separators where needed. Parameters buffer - the buffer where to store the serialized request request - the request struct containing the fields to serialize Returns length of the serialized request in bytes Undefined Behavior buffer is NULL request is NULL request doesn't fit in the buffer value_len , tag_len , path_len , body_len are different from the actual lengths of the strings path is NULL http1_serialize_write int32_t http1_serialize_write(const int fd, const http_request_t *restrict request) Description serializes on the fly and writes an HTTP/1.1 request to a file descriptor. Parameters fd - the file descriptor where to write the serialized request request - the request struct containing the fields to serialize Returns the result of the writev syscall -1 in case of error (see Errors ) Undefined Behavior fd is not a valid file descriptor request is NULL value_len , tag_len , path_len , body_len are different from the actual lengths of the strings path is NULL Errors writev syscall error the number of headers is bigger than what can be written in a single writev syscall, precisely if ( headers_count * 4 > IOV_MAX - 9)","title":"Serialization"},{"location":"api-reference/serialization/#serialization","text":"The following function prototypes can be found in the serialization.h header file. #include <flashhttp/serialization.h> These functions don't check the validity of messages , they assume that the message struct is already correctly filled with the right values.","title":"Serialization"},{"location":"api-reference/serialization/#http1_serialize","text":"uint32_t http1_serialize(char *restrict buffer, const http_request_t *restrict request)","title":"http1_serialize"},{"location":"api-reference/serialization/#description","text":"serializes an HTTP/1.1 request into a buffer, adding separators where needed.","title":"Description"},{"location":"api-reference/serialization/#parameters","text":"buffer - the buffer where to store the serialized request request - the request struct containing the fields to serialize","title":"Parameters"},{"location":"api-reference/serialization/#returns","text":"length of the serialized request in bytes","title":"Returns"},{"location":"api-reference/serialization/#undefined-behavior","text":"buffer is NULL request is NULL request doesn't fit in the buffer value_len , tag_len , path_len , body_len are different from the actual lengths of the strings path is NULL","title":"Undefined Behavior"},{"location":"api-reference/serialization/#http1_serialize_write","text":"int32_t http1_serialize_write(const int fd, const http_request_t *restrict request)","title":"http1_serialize_write"},{"location":"api-reference/serialization/#description_1","text":"serializes on the fly and writes an HTTP/1.1 request to a file descriptor.","title":"Description"},{"location":"api-reference/serialization/#parameters_1","text":"fd - the file descriptor where to write the serialized request request - the request struct containing the fields to serialize","title":"Parameters"},{"location":"api-reference/serialization/#returns_1","text":"the result of the writev syscall -1 in case of error (see Errors )","title":"Returns"},{"location":"api-reference/serialization/#undefined-behavior_1","text":"fd is not a valid file descriptor request is NULL value_len , tag_len , path_len , body_len are different from the actual lengths of the strings path is NULL","title":"Undefined Behavior"},{"location":"api-reference/serialization/#errors","text":"writev syscall error the number of headers is bigger than what can be written in a single writev syscall, precisely if ( headers_count * 4 > IOV_MAX - 9)","title":"Errors"},{"location":"building-and-testing/benchmarks/","text":"Benchmarks The benchmarks are the result of 1 million iterations per test, with randomly generated headers, path and body following a gaussian distribution. Thy're are performed on the static library compiled following the installation guide and they measure execution speed in terms of clock cycles rather than seconds, draw your own conclusions according to your CPU clock-speed. Comments: The benchmarks were run using only aligned memory, mostly static, with exception for the actual random strings. For write operations, /dev/null was used as the output file. This is to not factor in external factors such as disk speed, buffering, blocking. HTTP1 Run your own benchmarks To run your own benchmarks you can follow the steps below: Compile the library as described in the installation guide Compile the benchmark target: cmake --build . --target benchmark Run the benchmark executable: ./benchmark","title":"Benchmarks"},{"location":"building-and-testing/benchmarks/#benchmarks","text":"The benchmarks are the result of 1 million iterations per test, with randomly generated headers, path and body following a gaussian distribution. Thy're are performed on the static library compiled following the installation guide and they measure execution speed in terms of clock cycles rather than seconds, draw your own conclusions according to your CPU clock-speed.","title":"Benchmarks"},{"location":"building-and-testing/benchmarks/#comments","text":"The benchmarks were run using only aligned memory, mostly static, with exception for the actual random strings. For write operations, /dev/null was used as the output file. This is to not factor in external factors such as disk speed, buffering, blocking.","title":"Comments:"},{"location":"building-and-testing/benchmarks/#http1","text":"","title":"HTTP1"},{"location":"building-and-testing/benchmarks/#run-your-own-benchmarks","text":"To run your own benchmarks you can follow the steps below: Compile the library as described in the installation guide Compile the benchmark target: cmake --build . --target benchmark Run the benchmark executable: ./benchmark","title":"Run your own benchmarks"},{"location":"building-and-testing/installation/","text":"Installation Guide To install FlashHTTP you must compile it from source, as that will guarantee the best performance. Requirements CMake 3.10 or later gcc with c23 support CPU with misaligned memory access support Building Clone the repository: git clone https://github.com/Raimo33/FlashHTTP.git or download the source code from the release page Generate the build files: cmake . Build the library: cmake --build . --parallel Optionally install the library: cmake --install . --parallel Testing Compile the tests: cmake --build . --parallel --target test Run the test executable: ./test in case of failure, please open an issue on GitHub if there isn't one already.","title":"Installation"},{"location":"building-and-testing/installation/#installation-guide","text":"To install FlashHTTP you must compile it from source, as that will guarantee the best performance.","title":"Installation Guide"},{"location":"building-and-testing/installation/#requirements","text":"CMake 3.10 or later gcc with c23 support CPU with misaligned memory access support","title":"Requirements"},{"location":"building-and-testing/installation/#building","text":"Clone the repository: git clone https://github.com/Raimo33/FlashHTTP.git or download the source code from the release page Generate the build files: cmake . Build the library: cmake --build . --parallel Optionally install the library: cmake --install . --parallel","title":"Building"},{"location":"building-and-testing/installation/#testing","text":"Compile the tests: cmake --build . --parallel --target test Run the test executable: ./test in case of failure, please open an issue on GitHub if there isn't one already.","title":"Testing"}]}